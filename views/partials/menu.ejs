<!-- Outer container for sticky positioning and full-width background -->
<!-- Added pr-4 for consistent right padding -->
<div class="sticky top-0 z-[99] bg-gray-100 w-full pl-16 pr-4 lg:pl-[14vw]">
    <!-- Inner container for max-width, centering -->
    <div class="header-content max-w-6xl 2xl:max-w-screen-xl mx-auto flex items-center pt-[2vh] pb-[1vh]">

        <!-- Page Title Container -->
        <div class="posts-title-container bg-white p-[2px] pl-4 text-left mt-[0] shadow-md rounded-[15px] h-[50px] flex items-center flex-grow overflow-hidden">
            <h3 class="posts-title font-semibold text-base text-gray-800 ml-5 truncate">
                <%= headerTitle %> <!-- Corrected variable name -->
            </h3>
        </div>

        <!-- Chat Icon Container -->
        <!-- Added relative positioning to the container -->
        <div class="chat-search-container relative bg-white p-[2px] mt-[0] ml-[1vw] shadow-md rounded-[15px] w-14 lg:w-[6vw] h-[50px] flex justify-center items-center flex-shrink-0">
            <a href="/Chat" class="flex items-center justify-center w-full h-full">
                <img src="/img/email.png" alt="Chat Icon" class="icon w-5 h-auto">
                <!-- Global Unread Dot -->
                <span id="global-chat-unread-dot" class="w-2.5 h-2.5 bg-blue-500 rounded-full absolute top-1.5 right-1.5 hidden"></span>
            </a>
        </div>

        <!-- User Login/Dropdown Container -->
        <!-- Removed pr-4 from here, handled by outer wrapper's pr-4 -->
        <div class="user-log-container relative bg-white p-[2px] mt-[0] ml-[1vw] shadow-md rounded-[15px] w-14 lg:w-[10vw] h-[50px] flex justify-center items-center flex-shrink-0 overflow-visible">
            <% if (user) { %>
                <!-- User is logged in: Dropdown -->
                <div class="user-dropdown relative cursor-pointer w-full h-full flex items-center justify-center" id="userDropdown">
                    <!-- User Icon and Name -->
                    <div class="user-container flex items-center justify-center px-2">
                        <img src="/img/user.png" alt="User Icon" class="user-icon-dropdown w-5 h-auto lg:mr-1.5">
                        <span class="login-text text-sm text-gray-800 truncate hidden lg:inline"><%= user.username %></span>
                    </div>
                    <!-- Dropdown Content -->
                    <div id="dropdownContent" class="dropdown-content hidden absolute top-full right-0 mt-1 w-auto min-w-[150px] bg-white shadow-lg rounded-lg z-[9999] py-1 transition-all duration-300 ease-out">
                        <a href="/ManageAccount" class="block px-4 py-2 text-sm text-gray-700 hover:bg-green-600 hover:text-white rounded-md mx-1">Manage Account</a>
                        <a href="/LogOut" class="block px-4 py-2 text-sm text-gray-700 hover:bg-green-600 hover:text-white rounded-md mx-1">Log Out</a>
                    </div>
                </div>
            <% } else { %>
                <!-- User is not logged in: Login Link -->
                <a href="/LogIn?redirect=<%= encodeURIComponent(currentPath || '/') %>" id="login-link" class="flex items-center justify-center w-full h-full text-decoration-none">
                    <div class="user-container flex items-center justify-center">
                        <img src="/img/user.png" alt="User Icon" class="user-icon w-5 h-auto lg:mr-1.5">
                        <span class="login-text text-sm font-medium text-gray-800 uppercase hidden lg:inline">LOG-IN</span>
                    </div>
                </a>
            <% } %>
        </div>
    </div> <!-- End Inner container -->
</div> <!-- End Outer container -->

<!-- Include Socket.IO Client - Make sure this is loaded only once per page -->
<!-- If Socket.IO is already loaded globally (e.g., in header/footer), you can remove this line -->
<script src="/socket.io/socket.io.js"></script>

<!-- Keep the existing JavaScript for dropdown toggle -->
<script>
    document.addEventListener("DOMContentLoaded", function() {
        const userDropdown = document.getElementById("userDropdown");
        const dropdownContent = document.getElementById("dropdownContent");

        // Only add event listeners if userDropdown exists (i.e., user is logged in)
        if (userDropdown && dropdownContent) {
            // Toggle dropdown on click
            userDropdown.addEventListener("click", function(event) {
                event.stopPropagation(); // Prevent click from closing the dropdown immediately
                // Toggle the 'hidden' class
                dropdownContent.classList.toggle("hidden");
                // Optional: Add classes for animation if desired
                if (!dropdownContent.classList.contains('hidden')) {
                    // Add classes for entry animation (e.g., opacity, transform)
                    // dropdownContent.classList.add('opacity-100', 'translate-y-0');
                    // dropdownContent.classList.remove('opacity-0', '-translate-y-2'); // Example starting state
                } else {
                    // Optional: Reset animation classes if needed
                    // dropdownContent.classList.remove('opacity-100', 'translate-y-0');
                    // dropdownContent.classList.add('opacity-0', '-translate-y-2');
                }
            });

            // Close dropdown if clicking outside of it
            document.addEventListener("click", function(event) {
                // Check if the dropdown exists and is not hidden before trying to close
                if (dropdownContent && !dropdownContent.classList.contains('hidden')) {
                    if (!userDropdown.contains(event.target)) {
                        dropdownContent.classList.add("hidden");
                         // Optional: Reset animation classes
                        // dropdownContent.classList.remove('opacity-100', 'translate-y-0');
                        // dropdownContent.classList.add('opacity-0', '-translate-y-2');
                    }
                }
            });
        }
    });
</script>

<!-- Script for Global Unread Chat Dot -->
<script>
    document.addEventListener("DOMContentLoaded", function() {
        // console.log('[Global Unread] DOMContentLoaded.'); // Log DOM ready

        // --- CORRECTED USER CHECK ---
        // Use the EJS-injected userId to determine login status for this script block
        const userId = '<%= user?._id %>'; // Safely access user._id using EJS
        const userLoggedIn = userId && userId !== 'undefined' && userId !== ''; // Check if userId has a value
        // --- END CORRECTION ---

        const globalChatUnreadDot = document.getElementById('global-chat-unread-dot');

        // console.log(`[Global Unread] User Logged In Check (based on userId='${userId}'): ${userLoggedIn}`); // Updated log message

        if (!globalChatUnreadDot) {
            console.error('[Global Unread] Dot element #global-chat-unread-dot not found!');
            return;
        }

        if (userLoggedIn) {
            // const userId = '<%= user?._id %>'; // Already defined above
            // console.log(`[Global Unread] User ID found: ${userId}`);

            if (typeof io === 'undefined') {
                console.error('[Global Unread] Socket.IO client (io) not loaded!');
                globalChatUnreadDot.classList.add('hidden'); // Ensure hidden if io missing
                return;
            }

            // console.log('[Global Unread] Socket.IO client found. Attempting connection...');
            const socket = io(); // Connect to Socket.IO

            const updateDotVisibility = (hasUnread) => {
                // console.log(`[Global Unread] updateDotVisibility called with: ${hasUnread}`);
                if (!globalChatUnreadDot) {
                    console.error('[Global Unread] Dot element not found inside updateDotVisibility!');
                    return;
                }

                if (hasUnread) {
                    globalChatUnreadDot.classList.remove('hidden');
                    // console.log('[Global Unread] Dot should be VISIBLE (removed hidden class).');

                    // --- CSS Debugging ---
                    // Force reflow/repaint before checking styles (might help in some browsers)
                    void globalChatUnreadDot.offsetWidth;

                    const computedStyle = window.getComputedStyle(globalChatUnreadDot);
                    // console.log('[Global Unread CSS Check] Computed display:', computedStyle.display);
                    // console.log('[Global Unread CSS Check] Computed visibility:', computedStyle.visibility);
                    // console.log('[Global Unread CSS Check] Computed opacity:', computedStyle.opacity);
                    // console.log('[Global Unread CSS Check] Computed position:', computedStyle.position);
                    // console.log('[Global Unread CSS Check] Computed top/right:', computedStyle.top, computedStyle.right);
                    // --- End CSS Debugging ---

                    // --- Temporary Force Visibility (for debugging) ---
                    // Uncomment the line below to see if inline styles work, bypassing CSS classes
                    // globalChatUnreadDot.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important; position: absolute !important; top: 0.375rem !important; right: 0.375rem !important; width: 0.625rem; height: 0.625rem; background-color: blue; border-radius: 9999px;';
                    // --- End Temporary Force ---

                } else {
                    globalChatUnreadDot.classList.add('hidden');
                    // console.log('[Global Unread] Dot should be HIDDEN (added hidden class).');
                    // --- Temporary Force Visibility (Reset) ---
                    // If you uncommented the force above, uncomment this to reset when hiding
                    // globalChatUnreadDot.style.cssText = '';
                    // --- End Temporary Force ---
                }
            };

            // --- Function to request unread check ---
            const checkUnreadStatus = () => {
                if (socket.connected) {
                    // console.log('[Global Unread] Emitting checkGlobalUnread for user:', userId);
                    socket.emit('checkGlobalUnread', { userId: userId });
                } else {
                    console.warn('[Global Unread] Cannot check status, socket not connected.');
                }
            };
            // --- End function ---

            socket.on('connect', () => {
                // console.log('[Global Unread] Socket connected successfully. Socket ID:', socket.id);
                // --- Authenticate socket with user ID ---
                // Replace 'authenticate' with your actual event if different
                // console.log('[Global Unread] Authenticating socket with user ID:', userId);
                socket.emit('authenticate', userId);
                // --- End authentication ---

                // Initial check on connect
                checkUnreadStatus();
            });

            socket.on('updateGlobalUnread', (data) => {
                // console.log(`[Global Unread] Received 'updateGlobalUnread' event. Data:`, data);
                if (typeof data?.hasUnread !== 'undefined') {
                    updateDotVisibility(data.hasUnread);
                } else {
                     console.warn('[Global Unread] Received updateGlobalUnread event with invalid data format:', data);
                     updateDotVisibility(false); // Hide dot on invalid data
                }
            });

            // --- Listen for server trigger ---
            socket.on('triggerGlobalUnreadCheck', () => {
                // console.log("[Global Unread] Received 'triggerGlobalUnreadCheck' from server.");
                checkUnreadStatus(); // Re-check status when triggered
            });
            // --- End listener ---

            socket.on('disconnect', (reason) => {
                // console.log('[Global Unread] Socket disconnected:', reason);
                updateDotVisibility(false); // Hide dot on disconnect
            });

            socket.on('connect_error', (err) => {
                console.error('[Global Unread] Socket connection error:', err.message);
                updateDotVisibility(false); // Hide dot on connection error
            });

        } else {
            // console.log('[Global Unread] User not logged in or user._id missing. Ensuring dot is hidden.');
            globalChatUnreadDot.classList.add('hidden'); // Ensure dot is hidden if user is not logged in
        }
    });
</script>

